///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014 by audEERING                                      //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////

;;;;;;; component list ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[dataMemory].type=cDataMemory
printLevelStats=0

;;;;;;;;;;;;;;;;;;;;;;;;;;;; main section ;;;;;;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[waveIn].type=cWaveSource

[waveIn:cWaveSource]
writer.dmLevel=wave
buffersize_sec = 5.0
filename=\cm[inputfile(I){test.wav}:name of input file]
start=\cm[start{0}:audio start position in seconds]
end=\cm[end{-1}:audio end position in seconds, -1 for end of file]
monoMixdown=1
outFieldName = pcm


///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014 by audEERING                                      //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////

;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[gemapsv01a_frame60].type=cFramer
instance[gemapsv01a_win60].type=cWindower
instance[gemapsv01a_fft60].type=cTransformFFT
instance[gemapsv01a_fftmp60].type=cFFTmagphase

[gemapsv01a_frame60:cFramer]
reader.dmLevel=wave
writer.dmLevel=gemapsv01a_frame60
\{\cm[bufferModeRbConf{../shared/BufferModeRb.conf.inc}:path to included config to set the buffer mode for the standard ringbuffer levels]}
frameSize = 0.060
frameStep = 0.010
frameCenterSpecial = left

[gemapsv01a_win60:cWindower]
reader.dmLevel=gemapsv01a_frame60
writer.dmLevel=gemapsv01a_winG60
winFunc=gauss
gain=1.0
sigma=0.4

[gemapsv01a_fft60:cTransformFFT]
reader.dmLevel=gemapsv01a_winG60
writer.dmLevel=gemapsv01a_fftcG60
 ; for compatibility with 2.2.0 and older versions
;zeroPadSymmetric = 0

[gemapsv01a_fftmp60:cFFTmagphase]
reader.dmLevel=gemapsv01a_fftcG60
writer.dmLevel=gemapsv01a_fftmagG60
\{\cm[bufferModeRbLagConf{../shared/BufferModeRbLag.conf.inc}:path to included config to set the buffer mode for levels which will be joint with Viterbi smoothed -lagged- F0]}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[gemapsv01a_frame25].type=cFramer
instance[gemapsv01a_win25].type=cWindower
instance[gemapsv01a_fft25].type=cTransformFFT
instance[gemapsv01a_fftmp25].type=cFFTmagphase

[gemapsv01a_frame25:cFramer]
reader.dmLevel=wave
writer.dmLevel=gemapsv01a_frame25
\{\cm[bufferModeRbConf]}
frameSize = 0.020
frameStep = 0.010
frameCenterSpecial = left

[gemapsv01a_win25:cWindower]
reader.dmLevel=gemapsv01a_frame25
writer.dmLevel=gemapsv01a_winH25
winFunc=hamming

[gemapsv01a_fft25:cTransformFFT]
reader.dmLevel=gemapsv01a_winH25
writer.dmLevel=gemapsv01a_fftcH25
 ; for compatibility with 2.2.0 and older versions
;zeroPadSymmetric = 0

[gemapsv01a_fftmp25:cFFTmagphase]
reader.dmLevel=gemapsv01a_fftcH25
writer.dmLevel=gemapsv01a_fftmagH25
;;; CHECK!!!!!!!
;writer.levelconf.growDyn = 1
;writer.levelconf.isRb = 0


;;;;;;;;;;;;;;;;;;;; HPS pitch

[componentInstances:cComponentManager]
instance[gemapsv01a_scale].type=cSpecScale
instance[gemapsv01a_shs].type=cPitchShs

[gemapsv01a_scale:cSpecScale]
reader.dmLevel=gemapsv01a_fftmagG60
writer.dmLevel=gemapsv01a_hpsG60
\{\cm[bufferModeRbConf]}
copyInputName = 1
processArrayFields = 0
scale=octave
sourceScale = lin
interpMethod = spline
minF = 25
maxF = -1
nPointsTarget = 0
specSmooth = 1
specEnhance = 1
auditoryWeighting = 1 

[gemapsv01a_shs:cPitchShs]
reader.dmLevel=gemapsv01a_hpsG60
writer.dmLevel=gemapsv01a_pitchShsG60
\{\cm[bufferModeRbLagConf]}
copyInputName = 1
processArrayFields = 0
maxPitch = 1000
minPitch = 55
nCandidates = 6
scores = 1
voicing = 1
F0C1 = 0
voicingC1 = 0
F0raw = 1
voicingClip = 1
voicingCutoff = 0.700000
inputFieldSearch = Mag_octScale
octaveCorrection = 0
nHarmonics = 15
compressionFactor = 0.850000
greedyPeakAlgo = 1

;;;;; Pitch with Viterbi smoother
[componentInstances:cComponentManager]
instance[gemapsv01a_energy60].type=cEnergy

[gemapsv01a_energy60:cEnergy]
reader.dmLevel=gemapsv01a_winG60
writer.dmLevel=gemapsv01a_e60
 ; This must be > than buffersize of viterbi smoother
 ; writer.levelconf.nT=100
\{\cm[bufferModeRbLagConf]}
rms=1
log=0

[componentInstances:cComponentManager]
instance[gemapsv01a_pitchSmoothViterbi].type=cPitchSmootherViterbi

[gemapsv01a_pitchSmoothViterbi:cPitchSmootherViterbi]
reader.dmLevel=gemapsv01a_pitchShsG60
reader2.dmLevel=gemapsv01a_pitchShsG60
writer.dmLevel=gemapsv01a_logPitchRaw
copyInputName = 1
bufferLength=40
F0final = 1
F0finalLog = 1
F0finalEnv = 0
voicingFinalClipped = 0
voicingFinalUnclipped = 1
F0raw = 0
voicingC1 = 0
voicingClip = 0
wTvv =10.0
wTvvd= 5.0
wTvuv=10.0
wThr = 4.0
wTuu = 0.0
wLocal=2.0
wRange=1.0

[componentInstances:cComponentManager]
instance[gemapsv01a_volmerge].type = cValbasedSelector

[gemapsv01a_volmerge:cValbasedSelector]
reader.dmLevel = gemapsv01a_e60;gemapsv01a_logPitchRaw
writer.dmLevel = gemapsv01a_logPitch
\{\cm[bufferModeRbLagConf]}
idx=0
threshold=0.001
removeIdx=1
zeroVec=1
outputVal=0.0

;;;;;;;;;;;;;;;;;;; Voice Quality (VQ)

[componentInstances:cComponentManager]
instance[gemapsv01a_pitchJitter].type=cPitchJitter

[gemapsv01a_pitchJitter:cPitchJitter]
reader.dmLevel = wave
writer.dmLevel = gemapsv01a_jitterShimmer
\{\cm[bufferModeRbLagConf]}
copyInputName = 1
F0reader.dmLevel = gemapsv01a_logPitch
F0field = F0final
searchRangeRel = 0.100000
jitterLocal = 1
jitterDDP = 0
jitterLocalEnv = 0
jitterDDPEnv = 0
shimmerLocal = 0
shimmerLocalDB = 1
shimmerLocalEnv = 0
onlyVoiced = 0
logHNR = 0
 ; This must be larger than the viterbi pitch smoother lag
inputMaxDelaySec = 2.5
minNumPeriods = 2
minCC = 0.5
;useBrokenJitterThresh = 1

;;;;;;;;;;;;;;;;;;;;; Energy / loudness


[componentInstances:cComponentManager]
instance[gemapsv01a_melspec1].type=cMelspec
instance[gemapsv01a_audspec].type=cPlp
instance[gemapsv01a_audspecSum].type=cVectorOperation

[gemapsv01a_melspec1:cMelspec]
reader.dmLevel=gemapsv01a_fftmagH25
writer.dmLevel=gemapsv01a_melspec1
; htk compatible sample value scaling
htkcompatible = 0
nBands = 26
; use power spectrum instead of magnitude spectrum
usePower = 1
lofreq = 20
hifreq = 8000
specScale = mel
showFbank = 0

; perform auditory weighting of spectrum
[gemapsv01a_audspec:cPlp]
reader.dmLevel=gemapsv01a_melspec1
writer.dmLevel=gemapsv01a_audspec
firstCC = 0
lpOrder = 5
cepLifter = 22
compression = 0.33
htkcompatible = 0 
doIDFT = 0
doLpToCeps = 0
doLP = 0
doInvLog = 0
doAud = 1
doLog = 0
newRASTA=0
RASTA=0

[gemapsv01a_audspecSum:cVectorOperation]
reader.dmLevel = gemapsv01a_audspec
writer.dmLevel = gemapsv01a_loudness
; This must be larger than the F0 viterbi buffer length
; since audspecSum and F0 envelope are joint later!
\{\cm[bufferModeRbLagConf]}
nameAppend = loudness
copyInputName = 0
processArrayFields = 0
operation = ll1
nameBase = loudness

;;;;;;;;;;;;;; Formants ;;;;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[gemapsv01a_resampLpc].type=cSpecResample
instance[gemapsv01a_lpc].type=cLpc
instance[gemapsv01a_formantLpc].type=cFormantLpc

[gemapsv01a_resampLpc:cSpecResample]
// use fftcG60 ?  H25 has faster resampling
reader.dmLevel=gemapsv01a_fftcH25 
writer.dmLevel=gemapsv01a_outpR
targetFs = 11000

[gemapsv01a_lpc:cLpc]
reader.dmLevel=gemapsv01a_outpR
writer.dmLevel=gemapsv01a_lpc
p=11
method=acf
lpGain=0
saveLPCoeff=1
residual=0
forwardFilter=0
lpSpectrum=0

[gemapsv01a_formantLpc:cFormantLpc]
reader.dmLevel=gemapsv01a_lpc
writer.dmLevel=gemapsv01a_formants
\{\cm[bufferModeRbLagConf]}
saveIntensity=0
saveBandwidths=1
maxF=5500.0
minF=50.0
nFormants=5
useLpSpec=0
medianFilter=0
octaveCorrection=0

;;;;;;;;;;;;; Harmonics ;;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[gemapsv01a_harmonics].type = cHarmonics

  ;;;; default (template) configuration section for component 'cHarmonics' ;;;;
[gemapsv01a_harmonics:cHarmonics]
reader.dmLevel = gemapsv01a_logPitch;gemapsv01a_formants;gemapsv01a_fftmagG60
writer.dmLevel = gemapsv01a_harmonics
\{\cm[bufferModeRbLagConf]}
copyInputName = 0
processArrayFields = 0
includeSingleElementFields = 1
preserveFieldNames = 0
formantFrequencyFieldName = formantFreqLpc
formantFrequencyFieldNameIsFull = 1
formantBandwidthFieldName = formantBandwidthLpc
formantBandwidthFieldNameIsFull = 1
f0ElementName = F0final
f0ElementNameIsFull = 1
magSpecFieldName = pcm_fftMag
magSpecFieldNameIsFull = 1
nHarmonics = 100
harmonicDifferences = H1-H2;H1-A3
harmonicDifferencesLog = 1
nHarmonicMagnitudes = 0
firstHarmonicMagnitude = 1
outputLogRelMagnitudes = 1
formantAmplitudes=1
formantAmplitudesLogRel = 1
formantAmplitudesStart = 1
formantAmplitudesEnd = 3
computeAcfHnrLogdB = 1

;;;;;;;;;;;;;;; spectral
[componentInstances:cComponentManager]
instance[gemapsv01a_logSpectral].type=cSpectral

[gemapsv01a_logSpectral:cSpectral]
reader.dmLevel=gemapsv01a_fftmagH25
writer.dmLevel=gemapsv01a_logSpectral
\{\cm[bufferModeRbLagConf]}
flux = 0
centroid = 0
maxPos=0
minPos=0
entropy = 0
flatness = 0
harmonicity = 0
sharpness = 0
variance=0
skewness=0
kurtosis=0
alphaRatio = 1
hammarbergIndex = 1
slope = 0
slopes[0] = 0-500
slopes[1] = 500-1500
  ; NOTE: added this to sync with eGeMAPS set, should have no effect.
normBandEnergies = 1
squareInput = 1
useLogSpectrum = 1
freqRange = 0-5000
oldSlopeScale = 0

;;;;;;;;;;;; collecting, filtering, and renaming ;;;;;;;;;;;;;;;;,

/*
logSpectral     Hammarberg, AlphaRatio, spectralSlope  0-500, 500-1500
harmonics   H1-H2, H1-A3, HNRlog
logPitch    F0finalLog
jitterShimmer   jitterLocal, shimmerLocal
loudness
formants   F1-3 freq, F1 bandw (check!)
harmonics  F1-3 level relative
*/

[componentInstances:cComponentManager]
instance[gemapsv01a_lldSetSelectorE].type=cDataSelector
instance[gemapsv01a_lldSetSelectorF].type=cDataSelector
instance[gemapsv01a_lldSetSelectorLogF0].type=cDataSelector
instance[gemapsv01a_formantVoiced].type = cValbasedSelector
instance[gemapsv01a_lldSetSelectorNoF0LoudnNz].type = cDataSelector
instance[gemapsv01a_logSpectralVoiced].type = cValbasedSelector
instance[gemapsv01a_logSpectralUnvoiced].type = cValbasedSelector
instance[gemapsv01a_lldSetSelectorSpectralNz].type=cDataSelector
instance[gemapsv01a_lldSetSelectorSpectralZ].type=cDataSelector

[gemapsv01a_lldSetSelectorE:cDataSelector]
reader.dmLevel = gemapsv01a_loudness;gemapsv01a_logSpectral
writer.dmLevel = gemapsv01a_lldsetE
\{\cm[bufferModeRbConf]}
selected = loudness;pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500
newNames = Loudness;alphaRatio;hammarbergIndex;slope0-500;slope500-1500

[gemapsv01a_lldSetSelectorF:cDataSelector]
reader.dmLevel = gemapsv01a_logPitch;gemapsv01a_jitterShimmer;gemapsv01a_harmonics;gemapsv01a_formants
writer.dmLevel = gemapsv01a_lldsetF
\{\cm[bufferModeRbConf]}
selected = F0finalLog;jitterLocal;shimmerLocalDB;HarmonicsToNoiseRatioACFLogdB;HarmonicDifferenceLogRelH1-H2;HarmonicDifferenceLogRelH1-A3;formantFreqLpc[1];formantBandwidthLpc[1];FormantAmplitudeByMaxHarmonicLogRelF0[1];formantFreqLpc[2];FormantAmplitudeByMaxHarmonicLogRelF0[2];formantFreqLpc[3];FormantAmplitudeByMaxHarmonicLogRelF0[3]
newNames = F0semitoneFrom27.5Hz;jitterLocal;shimmerLocaldB;HNRdBACF;logRelF0-H1-H2;logRelF0-H1-A3;F1frequency;F1bandwidth;F1amplitudeLogRelF0;F2frequency;F2amplitudeLogRelF0;F3frequency;F3amplitudeLogRelF0

[gemapsv01a_lldSetSelectorLogF0:cDataSelector]
reader.dmLevel = gemapsv01a_logPitch
writer.dmLevel = gemapsv01a_lld_single_logF0
\{\cm[bufferModeRbConf]}
selected = F0finalLog
newNames = F0semitoneFrom27.5Hz

// select only formants where F0 > 0 for functionals
// (in LLD csv we output all of them..!)
[gemapsv01a_formantVoiced:cValbasedSelector]
reader.dmLevel = gemapsv01a_lld_single_logF0;gemapsv01a_formants
writer.dmLevel = gemapsv01a_formantsNz
\{\cm[bufferModeRbLagConf]}
idx=0
threshold=0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

[gemapsv01a_lldSetSelectorNoF0LoudnNz:cDataSelector]
reader.dmLevel = gemapsv01a_jitterShimmer;gemapsv01a_harmonics;gemapsv01a_formantsNz
writer.dmLevel = gemapsv01a_lldSetNoF0AndLoudnessNz
\{\cm[bufferModeRbConf]}
selected = jitterLocal;shimmerLocalDB;HarmonicsToNoiseRatioACFLogdB;HarmonicDifferenceLogRelH1-H2;HarmonicDifferenceLogRelH1-A3;formantFreqLpc[1];formantBandwidthLpc[1];FormantAmplitudeByMaxHarmonicLogRelF0[1];formantFreqLpc[2];FormantAmplitudeByMaxHarmonicLogRelF0[2];formantFreqLpc[3];FormantAmplitudeByMaxHarmonicLogRelF0[3]
newNames = jitterLocal;shimmerLocaldB;HNRdBACF;logRelF0-H1-H2;logRelF0-H1-A3;F1frequency;F1bandwidth;F1amplitudeLogRelF0;F2frequency;F2amplitudeLogRelF0;F3frequency;F3amplitudeLogRelF0

// select logspectral for voiced sounds
[gemapsv01a_logSpectralVoiced:cValbasedSelector]
reader.dmLevel = gemapsv01a_lld_single_logF0;gemapsv01a_logSpectral
writer.dmLevel = gemapsv01a_logSpectralVoiced
\{\cm[bufferModeRbLagConf]}
idx=0
threshold=0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

// select logspectral for voiced sounds
[gemapsv01a_logSpectralUnvoiced:cValbasedSelector]
reader.dmLevel = gemapsv01a_lld_single_logF0;gemapsv01a_logSpectral
writer.dmLevel = gemapsv01a_logSpectralUnvoiced
\{\cm[bufferModeRbLagConf]}
idx=0
invert = 1
threshold = 0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

[gemapsv01a_lldSetSelectorSpectralNz:cDataSelector]
reader.dmLevel = gemapsv01a_logSpectralVoiced
writer.dmLevel = gemapsv01a_lldSetSpectralNz
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500
newNames = alphaRatioV;hammarbergIndexV;slopeV0-500;slopeV500-1500

[gemapsv01a_lldSetSelectorSpectralZ:cDataSelector]
reader.dmLevel = gemapsv01a_logSpectralUnvoiced
writer.dmLevel = gemapsv01a_lldSetSpectralZ
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500
newNames = alphaRatioUV;hammarbergIndexUV;slopeUV0-500;slopeUV500-1500


;;;;;;;;;;;;;;;;  smoothing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[gemapsv01a_smoFnz].type=cContourSmoother
instance[gemapsv01a_smoE].type=cContourSmoother
instance[gemapsv01a_smoNoF0andLoudnNz].type=cContourSmoother
instance[gemapsv01a_smoSpectralZ].type=cContourSmoother
instance[gemapsv01a_smoSpectralNz].type=cContourSmoother

[gemapsv01a_smoFnz:cContourSmoother]
reader.dmLevel = gemapsv01a_lldsetF
writer.dmLevel = gemapsv01a_lldsetF_smo
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

[gemapsv01a_smoE:cContourSmoother]
reader.dmLevel = gemapsv01a_lldsetE
writer.dmLevel = gemapsv01a_lldsetE_smo
nameAppend = sma3
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 0

[gemapsv01a_smoNoF0andLoudnNz:cContourSmoother]
reader.dmLevel = gemapsv01a_lldSetNoF0AndLoudnessNz
writer.dmLevel = gemapsv01a_lldSetNoF0AndLoudnessNz_smo
\{\cm[bufferModeConf{../shared/BufferMode.conf.inc}:path to included config to set the buffer mode for the levels before the functionals]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

[gemapsv01a_smoSpectralZ:cContourSmoother]
reader.dmLevel = gemapsv01a_lldSetSpectralZ
writer.dmLevel = gemapsv01a_lldSetSpectralZ_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
; non-zero SMA is ok here, as it is inverted with 0's for the voiced parts
noZeroSma = 1

[gemapsv01a_smoSpectralNz:cContourSmoother]
reader.dmLevel = gemapsv01a_lldSetSpectralNz
writer.dmLevel = gemapsv01a_lldSetSpectralNz_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1


///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014 by audEERING                                      //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////

;; for LEq
[componentInstances:cComponentManager]
instance[egemapsv01a_energyRMS].type=cEnergy

[egemapsv01a_energyRMS:cEnergy]
reader.dmLevel = gemapsv01a_frame25
writer.dmLevel = egemapsv01a_energyRMS
\{\cm[bufferModeConf]}
htkcompatible = 0
rms = 0
energy2 = 1
log = 0


;;;;;;;;;;;;;;; spectral
[componentInstances:cComponentManager]
instance[egemapsv01a_logSpectral_flux].type=cSpectral

[egemapsv01a_logSpectral_flux:cSpectral]
reader.dmLevel=gemapsv01a_fftmagH25
writer.dmLevel=egemapsv01a_logSpectral_flux
\{\cm[bufferModeRbLagConf]}
flux = 1
centroid = 0
maxPos=0
minPos=0
entropy = 0
flatness = 0
harmonicity = 0
sharpness = 0
variance=0
skewness=0
kurtosis=0
alphaRatio = 0
hammarbergIndex = 0
slope = 0
normBandEnergies = 1
squareInput = 1
useLogSpectrum = 1
freqRange = 0-5000
oldSlopeScale = 0

;;;;;;;;;; cepstral ;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[egemapsv01a_melspecMfcc].type=cMelspec
instance[egemapsv01a_mfcc].type=cMfcc

[egemapsv01a_melspecMfcc:cMelspec]
reader.dmLevel=gemapsv01a_fftmagH25
writer.dmLevel=egemapsv01a_melspecMfcc
copyInputName = 1
processArrayFields = 1
; htk compatible sample value scaling
htkcompatible = 1
nBands = 26
; use power spectrum instead of magnitude spectrum
usePower = 1
lofreq = 20
hifreq = 8000
specScale = mel
inverse = 0

[egemapsv01a_mfcc:cMfcc]
reader.dmLevel=egemapsv01a_melspecMfcc
writer.dmLevel=egemapsv01a_mfcc
\{\cm[bufferModeRbLagConf]}
copyInputName = 0
processArrayFields = 1
firstMfcc = 1
lastMfcc  = 4
cepLifter = 22.0
htkcompatible = 1


;;;;;;;;;;;; collecting, filtering, and renaming ;;;;;;;;;;;;;;;;,

/*
logSpectral     Hammarberg, AlphaRatio, spectralSlope  0-500, 500-1500
harmonics   H1-H2, H1-A3, HNRlog
logPitch    F0finalLog
jitterShimmer   jitterLocal, shimmerLocal
loudness
formants   F1-3 freq, F1 bandw (check!)
harmonics  F1-3 level relative
*/

[componentInstances:cComponentManager]
instance[egemapsv01a_lldSetSelectorE].type=cDataSelector
instance[egemapsv01a_lldSetSelectorNoF0LoudnZ].type=cDataSelector
instance[egemapsv01a_lldSetSelectorNoF0LoudnNz].type = cDataSelector
instance[egemapsv01a_logSpectralVoiced].type = cValbasedSelector
instance[egemapsv01a_logSpectralUnvoiced].type = cValbasedSelector
instance[egemapsv01a_lldSetSelectorSpectralNz].type=cDataSelector
instance[egemapsv01a_lldSetSelectorSpectralZ].type=cDataSelector

[egemapsv01a_lldSetSelectorE:cDataSelector]
reader.dmLevel = gemapsv01a_loudness;gemapsv01a_logSpectral;egemapsv01a_logSpectral_flux;egemapsv01a_mfcc
writer.dmLevel = egemapsv01a_lldsetE
\{\cm[bufferModeRbConf]}
selected = loudness;pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500;pcm_fftMag_spectralFlux;mfcc[1];mfcc[2];mfcc[3];mfcc[4]
newNames = Loudness;alphaRatio;hammarbergIndex;slope0-500;slope500-1500;spectralFlux;mfcc1;mfcc2;mfcc3;mfcc4

[gemapsv01a_lldSetSelectorNoF0LoudnNz:cDataSelector]
reader.dmLevel = gemapsv01a_jitterShimmer;gemapsv01a_harmonics;gemapsv01a_formantsNz
writer.dmLevel = gemapsv01a_lldSetNoF0AndLoudnessNz
\{\cm[bufferModeRbConf]}
selected = jitterLocal;shimmerLocalDB;HarmonicsToNoiseRatioACFLogdB;HarmonicDifferenceLogRelH1-H2;HarmonicDifferenceLogRelH1-A3;formantFreqLpc[1];formantBandwidthLpc[1];FormantAmplitudeByMaxHarmonicLogRelF0[1];formantFreqLpc[2];FormantAmplitudeByMaxHarmonicLogRelF0[2];formantFreqLpc[3];FormantAmplitudeByMaxHarmonicLogRelF0[3]
newNames = jitterLocal;shimmerLocaldB;HNRdBACF;logRelF0-H1-H2;logRelF0-H1-A3;F1frequency;F1bandwidth;F1amplitudeLogRelF0;F2frequency;F2amplitudeLogRelF0;F3frequency;F3amplitudeLogRelF0


[egemapsv01a_lldSetSelectorNoF0LoudnZ:cDataSelector]
 ; gemapsv01a_logSpectral
reader.dmLevel = egemapsv01a_logSpectral_flux;egemapsv01a_mfcc
writer.dmLevel = egemapsv01a_lldSetNoF0AndLoudnessZ
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_spectralFlux;mfcc[1];mfcc[2];mfcc[3];mfcc[4]
newNames = spectralFlux;mfcc1;mfcc2;mfcc3;mfcc4

[egemapsv01a_lldSetSelectorNoF0LoudnNz:cDataSelector]
reader.dmLevel = gemapsv01a_jitterShimmer;gemapsv01a_harmonics;gemapsv01a_formantsNz
writer.dmLevel = egemapsv01a_lldSetNoF0AndLoudnessNz
\{\cm[bufferModeRbConf]}
selected = jitterLocal;shimmerLocalDB;HarmonicsToNoiseRatioACFLogdB;HarmonicDifferenceLogRelH1-H2;HarmonicDifferenceLogRelH1-A3;formantFreqLpc[1];formantBandwidthLpc[1];FormantAmplitudeByMaxHarmonicLogRelF0[1];formantFreqLpc[2];formantBandwidthLpc[2];FormantAmplitudeByMaxHarmonicLogRelF0[2];formantFreqLpc[3];formantBandwidthLpc[3];FormantAmplitudeByMaxHarmonicLogRelF0[3]
newNames = jitterLocal;shimmerLocaldB;HNRdBACF;logRelF0-H1-H2;logRelF0-H1-A3;F1frequency;F1bandwidth;F1amplitudeLogRelF0;F2frequency;F2bandwidth;F2amplitudeLogRelF0;F3frequency;F3bandwidth;F3amplitudeLogRelF0

// select logspectral and mfcc for voiced sounds
[egemapsv01a_logSpectralVoiced:cValbasedSelector]
reader.dmLevel = gemapsv01a_lld_single_logF0;gemapsv01a_logSpectral;egemapsv01a_logSpectral_flux;egemapsv01a_mfcc
writer.dmLevel = egemapsv01a_logSpectralVoiced
\{\cm[bufferModeRbLagConf]}
idx=0
threshold=0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

// select logspectral and mfcc for voiced sounds
[egemapsv01a_logSpectralUnvoiced:cValbasedSelector]
reader.dmLevel = gemapsv01a_lld_single_logF0;gemapsv01a_logSpectral;egemapsv01a_logSpectral_flux
writer.dmLevel = egemapsv01a_logSpectralUnvoiced
\{\cm[bufferModeRbLagConf]}
idx=0
invert = 1
threshold = 0.000001
removeIdx=1
zeroVec=1
outputVal=0.0

[egemapsv01a_lldSetSelectorSpectralNz:cDataSelector]
reader.dmLevel = egemapsv01a_logSpectralVoiced
writer.dmLevel = egemapsv01a_lldSetSpectralNz
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500;pcm_fftMag_spectralFlux;mfcc[1];mfcc[2];mfcc[3];mfcc[4]
newNames = alphaRatioV;hammarbergIndexV;slopeV0-500;slopeV500-1500;spectralFluxV;mfcc1V;mfcc2V;mfcc3V;mfcc4V

[egemapsv01a_lldSetSelectorSpectralZ:cDataSelector]
reader.dmLevel = egemapsv01a_logSpectralUnvoiced
writer.dmLevel = egemapsv01a_lldSetSpectralZ
\{\cm[bufferModeRbConf]}
selected = pcm_fftMag_alphaRatioDB;pcm_fftMag_hammarbergIndexDB;pcm_fftMag_logSpectralSlopeOfBand0-500;pcm_fftMag_logSpectralSlopeOfBand500-1500;pcm_fftMag_spectralFlux
newNames = alphaRatioUV;hammarbergIndexUV;slopeUV0-500;slopeUV500-1500;spectralFluxUV


;;;;;;;;;;;;;;;;  smoothing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[componentInstances:cComponentManager]
instance[egemapsv01a_smoE].type=cContourSmoother
instance[egemapsv01a_smoNoFLZ].type=cContourSmoother
instance[egemapsv01a_smoNoF0andLoudnNz].type=cContourSmoother
instance[egemapsv01a_smoSpectralZ].type=cContourSmoother
instance[egemapsv01a_smoSpectralNz].type=cContourSmoother

[egemapsv01a_smoE:cContourSmoother]
reader.dmLevel = egemapsv01a_lldsetE
writer.dmLevel = egemapsv01a_lldsetE_smo
nameAppend = sma3
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 0

[egemapsv01a_smoNoFLZ:cContourSmoother]
reader.dmLevel = egemapsv01a_lldSetNoF0AndLoudnessZ
writer.dmLevel = egemapsv01a_lldSetNoF0AndLoudnessZ_smo
\{\cm[bufferModeConf]}
nameAppend = sma3
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 0

[egemapsv01a_smoNoF0andLoudnNz:cContourSmoother]
reader.dmLevel = egemapsv01a_lldSetNoF0AndLoudnessNz
writer.dmLevel = egemapsv01a_lldSetNoF0AndLoudnessNz_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

[egemapsv01a_smoSpectralZ:cContourSmoother]
reader.dmLevel = egemapsv01a_lldSetSpectralZ
writer.dmLevel = egemapsv01a_lldSetSpectralZ_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
; non-zero SMA is ok here, as it is inverted with 0's for the voiced parts
noZeroSma = 1

[egemapsv01a_smoSpectralNz:cContourSmoother]
reader.dmLevel = egemapsv01a_lldSetSpectralNz
writer.dmLevel = egemapsv01a_lldSetSpectralNz_smo
\{\cm[bufferModeConf]}
nameAppend = sma3nz
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014 by audEERING                                      //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////

;;;;;;;;;;;;;;;; temporal statistics: ;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[gemapsv01a_smoF0].type=cContourSmoother
instance[gemapsv01a_smoLoudness].type=cContourSmoother
instance[gemapsv01a_temporalF0].type=cFunctionals
instance[gemapsv01a_temporalF0p].type=cFunctionals
instance[gemapsv01a_temporalLoudness].type=cFunctionals
instance[gemapsv01a_temporalSetNames].type=cDataSelector

;;smoothing ;;
[gemapsv01a_smoF0:cContourSmoother]
reader.dmLevel = gemapsv01a_lld_single_logF0
writer.dmLevel = gemapsv01a_lld_single_logF0_smo
\{\cm[bufferModeConf]}
copyInputName = 1
nameAppend = sma3nz
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 1

[gemapsv01a_smoLoudness:cContourSmoother]
reader.dmLevel = gemapsv01a_loudness
writer.dmLevel = gemapsv01a_loudness_smo
\{\cm[bufferModeConf]}
nameAppend = sma3
copyInputName = 1
noPostEOIprocessing = 0
smaWin = 3
noZeroSma = 0

; functionals for pitch onsets/offsets
[gemapsv01a_temporalF0:cFunctionals]
reader.dmLevel = gemapsv01a_lld_single_logF0_smo
writer.dmLevel = gemapsv01a_temporalF0
\{\cm[bufferModeRbConf]}
//nameAppend = ff0
copyInputName = 1
\{\cm[frameModeFunctionalsConf{../shared/FrameModeFunctionals.conf.inc}:path to included config to set frame mode for all functionals]}
functionalsEnabled = Segments 
Segments.maxNumSeg = 1000
Segments.segmentationAlgorithm = nonX
Segments.X = 0.0
Segments.numSegments = 1
Segments.meanSegLen = 1
Segments.maxSegLen = 0
Segments.minSegLen = 0
Segments.segLenStddev = 1
Segments.norm = second
nonZeroFuncts = 0
masterTimeNorm = second

// TODO: this is only unvoiced segments, combine with energy / loudness for true pauses!
; functionals for pitch onsets/offsets
[gemapsv01a_temporalF0p:cFunctionals]
reader.dmLevel = gemapsv01a_lld_single_logF0_smo
writer.dmLevel = gemapsv01a_temporalF0pause
\{\cm[bufferModeRbConf]}
copyInputName = 0
functNameAppend = f0pause
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Segments 
Segments.maxNumSeg = 1000
Segments.segmentationAlgorithm = eqX
Segments.X = 0.0
Segments.numSegments = 0
Segments.meanSegLen = 1
Segments.maxSegLen = 0
Segments.minSegLen = 0
Segments.segLenStddev = 1
Segments.norm = second
nonZeroFuncts = 0
masterTimeNorm = second

; functionals for pitch onsets/offsets
[gemapsv01a_temporalLoudness:cFunctionals]
reader.dmLevel = gemapsv01a_loudness_smo
writer.dmLevel = gemapsv01a_temporalLoudness
\{\cm[bufferModeRbConf]}
//nameAppend = ff0
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Peaks2 
Peaks2.numPeaks = 1
Peaks2.meanPeakDist = 0
Peaks2.meanPeakDistDelta = 0
Peaks2.peakDistStddev = 0
Peaks2.peakRangeAbs = 0
Peaks2.peakRangeRel = 0
Peaks2.peakMeanAbs = 0
Peaks2.peakMeanMeanDist = 0
Peaks2.peakMeanRel = 0
Peaks2.ptpAmpMeanAbs = 0
Peaks2.ptpAmpMeanRel = 0
Peaks2.ptpAmpStddevAbs = 0
Peaks2.ptpAmpStddevRel = 0
Peaks2.minRangeAbs = 0
Peaks2.minRangeRel = 0
Peaks2.minMeanAbs = 0
Peaks2.minMeanMeanDist = 0
Peaks2.minMeanRel = 0
Peaks2.mtmAmpMeanAbs = 0
Peaks2.mtmAmpMeanRel = 0
Peaks2.mtmAmpStddevAbs = 0
Peaks2.mtmAmpStddevRel = 0
Peaks2.meanRisingSlope = 0
Peaks2.maxRisingSlope = 0
Peaks2.minRisingSlope = 0
Peaks2.stddevRisingSlope = 0
Peaks2.meanFallingSlope = 0
Peaks2.maxFallingSlope = 0
Peaks2.minFallingSlope = 0
Peaks2.stddevFallingSlope = 0
Peaks2.norm = seconds
Peaks2.relThresh = 0.100000
Peaks2.dynRelThresh = 0
;Peaks2.posDbgOutp = minmax.txt
Peaks2.posDbgAppend = 0
Peaks2.consoleDbg = 0
nonZeroFuncts = 0
masterTimeNorm = second

;;;;;;;;;;;;;;;;;; filtering and renaming of names ;;;;;;;;;;;

[gemapsv01a_temporalSetNames:cDataSelector]
reader.dmLevel = gemapsv01a_temporalLoudness;gemapsv01a_temporalF0;gemapsv01a_temporalF0pause
writer.dmLevel = gemapsv01a_temporalSet
\{\cm[bufferModeRbConf]}
selected = loudness_sma3_numPeaks;F0semitoneFrom27.5Hz_sma3nz_numSegments;F0semitoneFrom27.5Hz_sma3nz_meanSegLen;F0semitoneFrom27.5Hz_sma3nz_segLenStddev;F0semitoneFrom27.5Hz_sma3nz__f0pause_meanSegLen;F0semitoneFrom27.5Hz_sma3nz__f0pause_segLenStddev
newNames = loudnessPeaksPerSec;VoicedSegmentsPerSec;MeanVoicedSegmentLengthSec;StddevVoicedSegmentLengthSec;MeanUnvoicedSegmentLength;StddevUnvoicedSegmentLength

;;;;;;;;;;;;;;;;;;;;; functionals / summaries ;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[gemapsv01a_functionalsF0].type=cFunctionals
instance[gemapsv01a_functionalsLoudness].type=cFunctionals
instance[gemapsv01a_functionalsMeanSpectralUV].type=cFunctionals
instance[gemapsv01a_functionalsMVRVoiced].type=cFunctionals

[gemapsv01a_functionalsF0:cFunctionals]
reader.dmLevel = gemapsv01a_lld_single_logF0_smo
writer.dmLevel = gemapsv01a_functionalsF0
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments ; Percentiles ; Peaks2
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
Moments.doRatioLimit = 0
Percentiles.quartiles = 0
Percentiles.iqr = 0
Percentiles.percentile[0] = 0.20
Percentiles.percentile[1] = 0.50
Percentiles.percentile[2] = 0.80
Percentiles.pctlrange[0] = 0-2
Percentiles.interp = 1
Peaks2.doRatioLimit = 0
Peaks2.numPeaks = 0
Peaks2.meanPeakDist = 0
Peaks2.meanPeakDistDelta = 0
Peaks2.peakDistStddev = 0
Peaks2.peakRangeAbs = 0
Peaks2.peakRangeRel = 0
Peaks2.peakMeanAbs = 0
Peaks2.peakMeanMeanDist = 0
Peaks2.peakMeanRel = 0
Peaks2.ptpAmpMeanAbs = 0
Peaks2.ptpAmpMeanRel = 0
Peaks2.ptpAmpStddevAbs = 0
Peaks2.ptpAmpStddevRel = 0
Peaks2.minRangeAbs = 0
Peaks2.minRangeRel = 0
Peaks2.minMeanAbs = 0
Peaks2.minMeanMeanDist = 0
Peaks2.minMeanRel = 0
Peaks2.mtmAmpMeanAbs = 0
Peaks2.mtmAmpMeanRel = 0
Peaks2.mtmAmpStddevAbs = 0
Peaks2.mtmAmpStddevRel = 0
Peaks2.meanRisingSlope = 1
Peaks2.maxRisingSlope = 0
Peaks2.minRisingSlope = 0
Peaks2.stddevRisingSlope = 1
Peaks2.meanFallingSlope = 1
Peaks2.maxFallingSlope = 0
Peaks2.minFallingSlope = 0
Peaks2.stddevFallingSlope = 1
Peaks2.norm = seconds
Peaks2.relThresh = 0.100000
Peaks2.dynRelThresh = 0
;Peaks2.posDbgOutp = minmax.txt
Peaks2.posDbgAppend = 0
Peaks2.consoleDbg = 0
nonZeroFuncts = 1
masterTimeNorm = segment

[gemapsv01a_functionalsLoudness:cFunctionals]
reader.dmLevel = gemapsv01a_loudness_smo
writer.dmLevel = gemapsv01a_functionalsLoudness
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments ; Percentiles ; Peaks2
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
Moments.doRatioLimit = 0
Percentiles.quartiles = 0
Percentiles.iqr = 0
Percentiles.percentile[0] = 0.20
Percentiles.percentile[1] = 0.50
Percentiles.percentile[2] = 0.80
Percentiles.pctlrange[0] = 0-2
Percentiles.interp = 1
Peaks2.doRatioLimit = 0
Peaks2.numPeaks = 0
Peaks2.meanPeakDist = 0
Peaks2.meanPeakDistDelta = 0
Peaks2.peakDistStddev = 0
Peaks2.peakRangeAbs = 0
Peaks2.peakRangeRel = 0
Peaks2.peakMeanAbs = 0
Peaks2.peakMeanMeanDist = 0
Peaks2.peakMeanRel = 0
Peaks2.ptpAmpMeanAbs = 0
Peaks2.ptpAmpMeanRel = 0
Peaks2.ptpAmpStddevAbs = 0
Peaks2.ptpAmpStddevRel = 0
Peaks2.minRangeAbs = 0
Peaks2.minRangeRel = 0
Peaks2.minMeanAbs = 0
Peaks2.minMeanMeanDist = 0
Peaks2.minMeanRel = 0
Peaks2.mtmAmpMeanAbs = 0
Peaks2.mtmAmpMeanRel = 0
Peaks2.mtmAmpStddevAbs = 0
Peaks2.mtmAmpStddevRel = 0
Peaks2.meanRisingSlope = 1
Peaks2.maxRisingSlope = 0
Peaks2.minRisingSlope = 0
Peaks2.stddevRisingSlope = 1
Peaks2.meanFallingSlope = 1
Peaks2.maxFallingSlope = 0
Peaks2.minFallingSlope = 0
Peaks2.stddevFallingSlope = 1
Peaks2.norm = seconds
Peaks2.relThresh = 0.100000
Peaks2.dynRelThresh = 0
;Peaks2.posDbgOutp = minmax.txt
Peaks2.posDbgAppend = 0
Peaks2.consoleDbg = 0
nonZeroFuncts = 0
masterTimeNorm = segment

[gemapsv01a_functionalsMeanSpectralUV:cFunctionals]
reader.dmLevel = gemapsv01a_lldSetSpectralZ_smo
writer.dmLevel = gemapsv01a_functionalsMeanSpectralUnvoiced
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 0
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
Moments.doRatioLimit = 0
nonZeroFuncts = 1
masterTimeNorm = segment

[gemapsv01a_functionalsMVRVoiced:cFunctionals]
reader.dmLevel = gemapsv01a_lldSetNoF0AndLoudnessNz_smo;gemapsv01a_lldSetSpectralNz_smo;
writer.dmLevel = gemapsv01a_functionalsMeanStddevVoiced
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
Moments.doRatioLimit = 0
nonZeroFuncts = 1
masterTimeNorm = segment



///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file, Geneva feature set <       //////////////////
/////////                                                            //////////////////
///////// (c) 2014 by audEERING                                      //////////////////
/////////     All rights reserved. See file COPYING for details.     //////////////////
///////////////////////////////////////////////////////////////////////////////////////


[componentInstances:cComponentManager]
instance[egemapsv01a_leqLin].type= cFunctionals
instance[egemapsv01a_leq].type = cVectorOperation

;; LEq
[egemapsv01a_leqLin:cFunctionals]
reader.dmLevel = egemapsv01a_energyRMS
writer.dmLevel = egemapsv01a_leqLin
// nameAppend =
preserveFields = 1
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
noPostEOIprocessing = 0
functionalsEnabled = Means
Means.amean = 1
Means.posamean = 0
Means.absmean = 0
Means.qmean = 0
Means.nzamean = 0
Means.nzabsmean = 0
Means.nzqmean = 0
Means.nzgmean = 0
Means.nnz = 0

[egemapsv01a_leq:cVectorOperation]
reader.dmLevel = egemapsv01a_leqLin
writer.dmLevel = egemapsv01a_leq
nameBase = equivalentSoundLevel
copyInputName = 1
processArrayFields = 0
operation = dBp
appendOperationToName = 1



;;;;;;;;;;;;;;;;;;;;; functionals / summaries ;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[egemapsv01a_functionalsMVR].type=cFunctionals
instance[egemapsv01a_functionalsMeanUV].type=cFunctionals
instance[egemapsv01a_functionalsMVRVoiced].type = cFunctionals

[egemapsv01a_functionalsMVR:cFunctionals]
reader.dmLevel = egemapsv01a_lldSetNoF0AndLoudnessZ_smo
writer.dmLevel = egemapsv01a_functionalsMeanStddevZ
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
nonZeroFuncts = 0
masterTimeNorm = segment

[egemapsv01a_functionalsMeanUV:cFunctionals]
reader.dmLevel = egemapsv01a_lldSetSpectralZ_smo
writer.dmLevel = egemapsv01a_functionalsMeanUnvoiced
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 0
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
nonZeroFuncts = 1
masterTimeNorm = segment

[egemapsv01a_functionalsMVRVoiced:cFunctionals]
reader.dmLevel = egemapsv01a_lldSetNoF0AndLoudnessNz_smo;egemapsv01a_lldSetSpectralNz_smo
writer.dmLevel = egemapsv01a_functionalsMeanStddevVoiced
\{\cm[bufferModeRbConf]}
copyInputName = 1
\{\cm[frameModeFunctionalsConf]}
functionalsEnabled = Moments
Moments.variance = 0
Moments.stddev = 0
Moments.stddevNorm = 2
Moments.skewness = 0
Moments.kurtosis = 0
Moments.amean = 1
nonZeroFuncts = 1
masterTimeNorm = segment



[componentInstances:cComponentManager]
instance[lldconcat].type=cVectorConcat
instance[llddeconcat].type=cVectorConcat
instance[funcconcat].type=cVectorConcat

[lldconcat:cVectorConcat]
reader.dmLevel = egemapsv01a_lldsetE_smo
writer.dmLevel = lld
includeSingleElementFields = 1

[llddeconcat:cVectorConcat]
reader.dmLevel = gemapsv01a_lldsetF_smo
writer.dmLevel = lld_de
includeSingleElementFields = 1

[funcconcat:cVectorConcat]
reader.dmLevel = gemapsv01a_functionalsF0;gemapsv01a_functionalsLoudness;egemapsv01a_functionalsMeanStddevZ;egemapsv01a_functionalsMeanStddevVoiced;egemapsv01a_functionalsMeanUnvoiced;gemapsv01a_temporalSet;egemapsv01a_leq
writer.dmLevel = func
includeSingleElementFields = 1

///////////////////////////////////////////////////////////////////////////////////////
///////// > openSMILE configuration file for data output <           //////////////////
/////////                                                            //////////////////
///////// (c) 2014-2016 audEERING,                                   //////////////////
/////////     All rights reserverd. See file COPYING for details     //////////////////
///////////////////////////////////////////////////////////////////////////////////////


/*
   This file can be included as data output file for standard feature
   extraction configuration files. It provides commandline options
   for the batch extraction GUI, and supports LLD and Functionals (summaries)
   saving.

   It requires the main extrator configuration file to provide the following
   data memory levels:  lld, lld_de, and func
 */

;;;;;;;;; output LLD features to CSV ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[componentInstances:cComponentManager]
instance[lldsink].type=cCsvSink
instance[lldhtksink].type=cHtkSink
instance[lldarffsink].type=cArffSink
instance[arffsink].type=cArffSink
instance[csvsink].type=cCsvSink
instance[htksink].type=cHtkSink

[lldsink:cCsvSink]
reader.dmLevel = lld;lld_de
filename=\cm[lldcsvoutput(D){?}:output csv file for LLD, disabled by default ?, only written if filename given]
instanceName=\cm[instname(N){unknown}:instance name]
append = \cm[appendcsvlld{0}:set to 1 to append to the LLD output csv file, default is not to append]
timestamp = \cm[timestampcsvlld{1}:set to 0 to suppress timestamp column, default is 1, i.e. to show timestamp in second column]
number = 0
printHeader = \cm[headercsvlld{1}:set to 0 to suppress header line with feature names, default is 1, i.e. to show header line]
errorOnNoOutput = 1

[lldhtksink:cHtkSink]
reader.dmLevel = lld;lld_de
filename=\cm[lldhtkoutput{?}:output HTK binary file for LLD, disabled by default ?, only written if filename given]
append = \cm[appendhtklld{0}:set to 1 to append to the LLD output htk file, default is not to append]
  ; this is broken for HTK sink...
errorOnNoOutput = 0  
parmKind = 9

[lldarffsink:cArffSink]
reader.dmLevel = lld;lld_de
frameIndex = 0
frameTime = \cm[timestamparfflld{1}:set to 0 to suppress timestamp column, default is 1, i.e. to show timestamp in second column]
filename=\cm[lldarffoutput{?}:name of WEKA Arff output file, set to a valid filename to enable this output sink]
relation=\cm[relation{openSMILE_features}:arff relation attribute, feature set name and/or corpus name]
instanceName=\cm[instname]
 ;; use this line instead of the above to always set the instance name to the
 ;; name of the input wave file
 ;instanceName=\cm[inputfile]
\{\cm[lldarfftargetsfile{../shared/arff_targets.conf.inc}:name of arff targets include file]}
append=\cm[appendarfflld{1}:set to 0 to disable appending to an existing arff parameter summary file, given by the arffoutput option]
errorOnNoOutput = 1

[arffsink:cArffSink]
reader.dmLevel=func
frameIndex = 0
frameTime = \cm[timestamparff{0}:set to 1 to include timestamp column, default is 0, i.e. to not save timestamp in second column]
frameTimeAdd=\cm[frameTimeAdd{0}:frame time offset -start of segment in seconds- used by avec2013]
filename=\cm[output(O){?}:name of WEKA Arff output file, set to a valid filename to enable this output sink]
relation=\cm[relation{openSMILE_features}:arff relation attribute, feature set name and/or corpus name]
instanceName=\cm[instname]
 ;; use this line instead of the above to always set the instance name to the
 ;; name of the input wave file
 ;instanceName=\cm[inputfile]
\{\cm[arfftargetsfile{arff_targets.conf.inc}:name of arff targets include file]}
append=\cm[appendarff{1}:set to 0 to disable appending to an existing arff parameter summary file, given by the arffoutput option]
errorOnNoOutput = 1

[csvsink:cCsvSink]
reader.dmLevel = func
filename=\cm[csvoutput{?}:output CSV file for summarised parameters, set to a valid filename to enable this output sink, data is appended if file exists]
append=\cm[appendcsv{1}:set to 0 to disable appending to an existing csv parameter summary file, given by the csvoutput option]
frameIndex=0
frameTime=\cm[timestampcsv{1}:set to 0 to suppress timestamp column, default is 1, i.e. to show timestamp in second column]
instanceName=\cm[instname]
errorOnNoOutput = 1
printHeader = \cm[headercsv{1}:set to 0 to suppress header line with feature names, default is 1, i.e. to show header line]

  ; TODO: output without a frame period does not work so that HTK (HList) can read it!
[htksink:cHtkSink]
reader.dmLevel = func
filename=\cm[htkoutput{?}:output HTK file for summarised parameters, set to a valid filename to enable this output sink, no append by default, use -appendstatichtk option to enable]
append=\cm[appendhtk{0}:set to 1 to enable appending to an existing HTK parameter summary file, given by the htkoutput option]
parmKind = 9
  ; this is broken for HTK sink...
errorOnNoOutput = 0
 ; avoid broken files which HTK cannot read for period approx. > 0.06 (int16 overflow)
;forcePeriod = 0.01


